package skiprope

import (
	"math/rand"
	"time"
	"unicode/utf8"
	// "log"
)

var src = rand.New(rand.NewSource(time.Now().UnixNano()))

func randInt() (retVal int) {
	retVal = 1
	for retVal < MaxHeight-1 && src.Intn(100) < Bias {
		retVal++
	}
	return retVal
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func clamp(a, minVal, maxVal int) int {
	return max(minVal, min(maxVal, a))
}

// byteOffset takes a slice of bytes, and returns the index at which the expected number of runes there is
func byteOffset(a []byte, runes int) (offset int) {
	if runes == 0 {
		return 0
	}

	var runeCount int
	for offset < len(a) && runeCount < runes {
		b := a[offset]
		if b < utf8.RuneSelf {
			// fast path
			offset++
			runeCount++
			continue
		}
		// _, size := utf8.DecodeRune(a[offset:])
		size := int(first[b] & 7) // no checking of correct runes or not
		offset += size
		runeCount++
	}
	// original code - commented out for posterity's sake. The loop below has been optimized
	// for _, size := utf8.DecodeRune(a[offset:]); offset < len(a) && runeCount < runes; _, size = utf8.DecodeRune(a[offset:]) {
	// 	offset += size
	// 	runeCount++
	// }
	return offset
}

// first is information about the first byte in a UTF-8 sequence.

const (
	xx = 0xF1 // invalid: size 1
	as = 0xF0 // ASCII: size 1
	s1 = 0x02 // accept 0, size 2
	s2 = 0x13 // accept 1, size 3
	s3 = 0x03 // accept 0, size 3
	s4 = 0x23 // accept 2, size 3
	s5 = 0x34 // accept 3, size 4
	s6 = 0x04 // accept 0, size 4
	s7 = 0x44 // accept 4, size 4
)

var first = [256]uint8{
	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x00-0x0F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x10-0x1F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x20-0x2F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x30-0x3F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x40-0x4F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x50-0x5F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x60-0x6F
	as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, as, // 0x70-0x7F

	//   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x80-0x8F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0x90-0x9F
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xA0-0xAF
	xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xB0-0xBF
	xx, xx, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xC0-0xCF
	s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, s1, // 0xD0-0xDF
	s2, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s3, s4, s3, s3, // 0xE0-0xEF
	s5, s6, s6, s6, s7, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, xx, // 0xF0-0xFF

}
